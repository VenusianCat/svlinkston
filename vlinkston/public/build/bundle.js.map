{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/svelte/store/index.mjs","../../src/stores.js","../../node_modules/svelte-dnd-action/src/helpers/dispatcher.js","../../node_modules/svelte-dnd-action/src/constants.js","../../node_modules/svelte-dnd-action/src/helpers/intersection.js","../../node_modules/svelte-dnd-action/src/helpers/listUtil.js","../../node_modules/svelte-dnd-action/src/helpers/scroller.js","../../node_modules/svelte-dnd-action/src/helpers/util.js","../../node_modules/svelte-dnd-action/src/helpers/observer.js","../../node_modules/svelte-dnd-action/src/helpers/windowScroller.js","../../node_modules/svelte-dnd-action/src/helpers/styler.js","../../node_modules/svelte-dnd-action/src/pointerAction.js","../../node_modules/svelte-dnd-action/src/helpers/aria.js","../../node_modules/svelte-dnd-action/src/keyboardAction.js","../../node_modules/svelte-dnd-action/src/action.js","../../src/Link.svelte","../../src/Set.svelte","../../src/Group.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.43.1' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import {\r\n\treadable,\r\n\twritable\r\n} from \"svelte/store\";\r\n\r\n\r\n\r\n/* BOOKMARKS STORE */\r\nexport const bookmarks = writable([\r\n\t{\r\n\t\tid: 'group-1',\r\n\t\ttitle: 'default',\r\n\t\tsets: [\r\n\t\t]\r\n\t}\r\n]);\r\n\r\n\r\n\r\n\r\n\r\n/* APP STATE STORE */\r\nexport const appState = writable({\r\n\tcurrentTabIndex: 0\r\n});\r\n\r\n\r\n\r\n\r\n\r\n/* CONFIG GOES HERE!!! */\r\nlet localhostAjaxURL = 'http://localhost/working/backend/ajax.php';\r\nlet deployedAjaxURL = './ajax.php';\r\nlet ajaxURL = (window.location.hostname === \"localhost\") ? localhostAjaxURL : deployedAjaxURL;\r\n\r\nexport const config = readable({\r\n\tajaxURL\r\n});\r\n","// external events\nconst FINALIZE_EVENT_NAME = \"finalize\";\nconst CONSIDER_EVENT_NAME = \"consider\";\n\n/**\n * @typedef {Object} Info\n * @property {string} trigger\n * @property {string} id\n * @property {string} source\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchFinalizeEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(FINALIZE_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n/**\n * Dispatches a consider event\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchConsiderEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(CONSIDER_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n// internal events\nexport const DRAGGED_ENTERED_EVENT_NAME = \"draggedEntered\";\nexport const DRAGGED_LEFT_EVENT_NAME = \"draggedLeft\";\nexport const DRAGGED_OVER_INDEX_EVENT_NAME = \"draggedOverIndex\";\nexport const DRAGGED_LEFT_DOCUMENT_EVENT_NAME = \"draggedLeftDocument\";\n\nexport const DRAGGED_LEFT_TYPES = {\n    LEFT_FOR_ANOTHER: \"leftForAnother\",\n    OUTSIDE_OF_ANY: \"outsideOfAny\"\n};\n\nexport function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\n\n/**\n * @param containerEl - the dropzone the element left\n * @param draggedEl - the dragged element\n * @param theOtherDz - the new dropzone the element entered\n */\nexport function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl, theOtherDz) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz}\n        })\n    );\n}\n\nexport function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY}\n        })\n    );\n}\nexport function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\nexport function dispatchDraggedLeftDocument(draggedEl) {\n    window.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {\n            detail: {draggedEl}\n        })\n    );\n}\n","import {DRAGGED_ENTERED_EVENT_NAME, DRAGGED_LEFT_EVENT_NAME, DRAGGED_OVER_INDEX_EVENT_NAME} from \"./helpers/dispatcher\";\n\nexport const TRIGGERS = {\n    DRAG_STARTED: \"dragStarted\",\n    DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_ENTERED_ANOTHER: \"dragEnteredAnother\",\n    DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,\n    DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_ALL: \"draggedLeftAll\",\n    DROPPED_INTO_ZONE: \"droppedIntoZone\",\n    DROPPED_INTO_ANOTHER: \"droppedIntoAnother\",\n    DROPPED_OUTSIDE_OF_ANY: \"droppedOutsideOfAny\",\n    DRAG_STOPPED: \"dragStopped\"\n};\n\nexport const SOURCES = {\n    POINTER: \"pointer\",\n    KEYBOARD: \"keyboard\"\n};\n\nexport const SHADOW_ITEM_MARKER_PROPERTY_NAME = \"isDndShadowItem\";\nexport const SHADOW_ELEMENT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item\";\nexport const SHADOW_PLACEHOLDER_ITEM_ID = \"id:dnd-shadow-placeholder-0000\";\nexport const DRAGGED_ELEMENT_ID = \"dnd-action-dragged-el\";\n\nexport let ITEM_ID_KEY = \"id\";\nlet activeDndZoneCount = 0;\nexport function incrementActiveDropZoneCount() {\n    activeDndZoneCount++;\n}\nexport function decrementActiveDropZoneCount() {\n    if (activeDndZoneCount === 0) {\n        throw new Error(\"Bug! trying to decrement when there are no dropzones\");\n    }\n    activeDndZoneCount--;\n}\n\n/**\n * Allows using another key instead of \"id\" in the items data. This is global and applies to all dndzones.\n * Has to be called when there are no rendered dndzones whatsoever.\n * @param {String} newKeyName\n * @throws {Error} if it was called when there are rendered dndzones or if it is given the wrong type (not a string)\n */\nexport function overrideItemIdKeyNameBeforeInitialisingDndZones(newKeyName) {\n    if (activeDndZoneCount > 0) {\n        throw new Error(\"can only override the id key before initialising any dndzone\");\n    }\n    if (typeof newKeyName !== \"string\") {\n        throw new Error(\"item id key has to be a string\");\n    }\n    printDebug(() => [\"overriding item id key name\", newKeyName]);\n    ITEM_ID_KEY = newKeyName;\n}\n\nexport const isOnServer = typeof window === \"undefined\";\n\nexport let printDebug = () => {};\n\n/**\n * Allows the user to show/hide console debug output\n * * @param {Boolean} isDebug\n */\nexport function setDebugMode(isDebug) {\n    if (isDebug) {\n        printDebug = (generateMessage, logFunction = console.debug) => {\n            const message = generateMessage();\n            if (Array.isArray(message)) {\n                logFunction(...message);\n            } else {\n                logFunction(message);\n            }\n        };\n    } else {\n        printDebug = () => {};\n    }\n}\n","// This is based off https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms/57876601#57876601\n// It removes the transforms that are potentially applied by the flip animations\n/**\n * Gets the bounding rect but removes transforms (ex: flip animation)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getBoundingRectNoTransforms(el) {\n    let ta;\n    const rect = el.getBoundingClientRect();\n    const style = getComputedStyle(el);\n    const tx = style.transform;\n\n    if (tx) {\n        let sx, sy, dx, dy;\n        if (tx.startsWith(\"matrix3d(\")) {\n            ta = tx.slice(9, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[5];\n            dx = +ta[12];\n            dy = +ta[13];\n        } else if (tx.startsWith(\"matrix(\")) {\n            ta = tx.slice(7, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[3];\n            dx = +ta[4];\n            dy = +ta[5];\n        } else {\n            return rect;\n        }\n\n        const to = style.transformOrigin;\n        const x = rect.x - dx - (1 - sx) * parseFloat(to);\n        const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(\" \") + 1));\n        const w = sx ? rect.width / sx : el.offsetWidth;\n        const h = sy ? rect.height / sy : el.offsetHeight;\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h,\n            top: y,\n            right: x + w,\n            bottom: y + h,\n            left: x\n        };\n    } else {\n        return rect;\n    }\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position and removes transforms)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRectNoTransforms(el) {\n    const rect = getBoundingRectNoTransforms(el);\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRect(el) {\n    const rect = el.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * finds the center :)\n * @typedef {Object} Rect\n * @property {number} top\n * @property {number} bottom\n * @property {number} left\n * @property {number} right\n * @param {Rect} rect\n * @return {{x: number, y: number}}\n */\nexport function findCenter(rect) {\n    return {\n        x: (rect.left + rect.right) / 2,\n        y: (rect.top + rect.bottom) / 2\n    };\n}\n\n/**\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n * @param {Point} pointA\n * @param {Point} pointB\n * @return {number}\n */\nfunction calcDistance(pointA, pointB) {\n    return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n}\n\n/**\n * @param {Point} point\n * @param {Rect} rect\n * @return {boolean|boolean}\n */\nexport function isPointInsideRect(point, rect) {\n    return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;\n}\n\n/**\n * find the absolute coordinates of the center of a dom element\n * @param el {HTMLElement}\n * @returns {{x: number, y: number}}\n */\nexport function findCenterOfElement(el) {\n    return findCenter(getAbsoluteRect(el));\n}\n\n/**\n * @param {HTMLElement} elA\n * @param {HTMLElement} elB\n * @return {boolean}\n */\nexport function isCenterOfAInsideB(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const rectOfB = getAbsoluteRectNoTransforms(elB);\n    return isPointInsideRect(centerOfA, rectOfB);\n}\n\n/**\n * @param {HTMLElement|ChildNode} elA\n * @param {HTMLElement|ChildNode} elB\n * @return {number}\n */\nexport function calcDistanceBetweenCenters(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const centerOfB = findCenterOfElement(elB);\n    return calcDistance(centerOfA, centerOfB);\n}\n\n/**\n * @param {HTMLElement} el - the element to check\n * @returns {boolean} - true if the element in its entirety is off screen including the scrollable area (the normal dom events look at the mouse rather than the element)\n */\nexport function isElementOffDocument(el) {\n    const rect = getAbsoluteRect(el);\n    return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;\n}\n\n/**\n * If the point is inside the element returns its distances from the sides, otherwise returns null\n * @param {Point} point\n * @param {HTMLElement} el\n * @return {null|{top: number, left: number, bottom: number, right: number}}\n */\nexport function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {\n    const rect = getAbsoluteRect(el);\n    if (!isPointInsideRect(point, rect)) {\n        return null;\n    }\n    return {\n        top: point.y - rect.top,\n        bottom: rect.bottom - point.y,\n        left: point.x - rect.left,\n        // TODO - figure out what is so special about right (why the rect is too big)\n        right: Math.min(rect.right, document.documentElement.clientWidth) - point.x\n    };\n}\n","import {isCenterOfAInsideB, calcDistanceBetweenCenters, getAbsoluteRectNoTransforms, isPointInsideRect, findCenterOfElement} from \"./intersection\";\nimport {printDebug, SHADOW_ELEMENT_ATTRIBUTE_NAME} from \"../constants\";\n\nlet dzToShadowIndexToRect;\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution. Should be called after every drag operation\n */\nexport function resetIndexesCache() {\n    printDebug(() => \"resetting indexes cache\");\n    dzToShadowIndexToRect = new Map();\n}\nresetIndexesCache();\n\n/**\n * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.\n * Helpful in order to determine \"would be index\" more effectively\n * @param {HTMLElement} dz\n * @return {number} - the shadow element index\n */\nfunction cacheShadowRect(dz) {\n    const shadowElIndex = Array.from(dz.children).findIndex(child => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));\n    if (shadowElIndex >= 0) {\n        if (!dzToShadowIndexToRect.has(dz)) {\n            dzToShadowIndexToRect.set(dz, new Map());\n        }\n        dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));\n        return shadowElIndex;\n    }\n    return undefined;\n}\n\n/**\n * @typedef {Object} Index\n * @property {number} index - the would be index\n * @property {boolean} isProximityBased - false if the element is actually over the index, true if it is not over it but this index is the closest\n */\n/**\n * Find the index for the dragged element in the list it is dragged over\n * @param {HTMLElement} floatingAboveEl\n * @param {HTMLElement} collectionBelowEl\n * @returns {Index|null} -  if the element is over the container the Index object otherwise null\n */\nexport function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {\n    if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {\n        return null;\n    }\n    const children = collectionBelowEl.children;\n    // the container is empty, floating element should be the first\n    if (children.length === 0) {\n        return {index: 0, isProximityBased: true};\n    }\n    const shadowElIndex = cacheShadowRect(collectionBelowEl);\n\n    // the search could be more efficient but keeping it simple for now\n    // a possible improvement: pass in the lastIndex it was found in and check there first, then expand from there\n    for (let i = 0; i < children.length; i++) {\n        if (isCenterOfAInsideB(floatingAboveEl, children[i])) {\n            const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);\n            if (cachedShadowRect) {\n                if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {\n                    return {index: shadowElIndex, isProximityBased: false};\n                }\n            }\n            return {index: i, isProximityBased: false};\n        }\n    }\n    // this can happen if there is space around the children so the floating element has\n    //entered the container but not any of the children, in this case we will find the nearest child\n    let minDistanceSoFar = Number.MAX_VALUE;\n    let indexOfMin = undefined;\n    // we are checking all of them because we don't know whether we are dealing with a horizontal or vertical container and where the floating element entered from\n    for (let i = 0; i < children.length; i++) {\n        const distance = calcDistanceBetweenCenters(floatingAboveEl, children[i]);\n        if (distance < minDistanceSoFar) {\n            minDistanceSoFar = distance;\n            indexOfMin = i;\n        }\n    }\n    return {index: indexOfMin, isProximityBased: true};\n}\n","import {calcInnerDistancesBetweenPointAndSidesOfElement} from \"./intersection\";\nconst SCROLL_ZONE_PX = 25;\n\nexport function makeScroller() {\n    let scrollingInfo;\n    function resetScrolling() {\n        scrollingInfo = {directionObj: undefined, stepPx: 0};\n    }\n    resetScrolling();\n    // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x\n    function scrollContainer(containerEl) {\n        const {directionObj, stepPx} = scrollingInfo;\n        if (directionObj) {\n            containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);\n            window.requestAnimationFrame(() => scrollContainer(containerEl));\n        }\n    }\n    function calcScrollStepPx(distancePx) {\n        return SCROLL_ZONE_PX - distancePx;\n    }\n\n    /**\n     * If the pointer is next to the sides of the element to scroll, will trigger scrolling\n     * Can be called repeatedly with updated pointer and elementToScroll values without issues\n     * @return {boolean} - true if scrolling was needed\n     */\n    function scrollIfNeeded(pointer, elementToScroll) {\n        if (!elementToScroll) {\n            return false;\n        }\n        const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);\n        if (distances === null) {\n            resetScrolling();\n            return false;\n        }\n        const isAlreadyScrolling = !!scrollingInfo.directionObj;\n        let [scrollingVertically, scrollingHorizontally] = [false, false];\n        // vertical\n        if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {\n            if (distances.bottom < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: 1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);\n            } else if (distances.top < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: -1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.top);\n            }\n            if (!isAlreadyScrolling && scrollingVertically) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        // horizontal\n        if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {\n            if (distances.right < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: 1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.right);\n            } else if (distances.left < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: -1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.left);\n            }\n            if (!isAlreadyScrolling && scrollingHorizontally) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        resetScrolling();\n        return false;\n    }\n\n    return {\n        scrollIfNeeded,\n        resetScrolling\n    };\n}\n","/**\n * @param {Object} object\n * @return {string}\n */\nexport function toString(object) {\n    return JSON.stringify(object, null, 2);\n}\n\n/**\n * Finds the depth of the given node in the DOM tree\n * @param {HTMLElement} node\n * @return {number} - the depth of the node\n */\nexport function getDepth(node) {\n    if (!node) {\n        throw new Error(\"cannot get depth of a falsy node\");\n    }\n    return _getDepth(node, 0);\n}\nfunction _getDepth(node, countSoFar = 0) {\n    if (!node.parentElement) {\n        return countSoFar - 1;\n    }\n    return _getDepth(node.parentElement, countSoFar + 1);\n}\n\n/**\n * A simple util to shallow compare objects quickly, it doesn't validate the arguments so pass objects in\n * @param {Object} objA\n * @param {Object} objB\n * @return {boolean} - true if objA and objB are shallow equal\n */\nexport function areObjectsShallowEqual(objA, objB) {\n    if (Object.keys(objA).length !== Object.keys(objB).length) {\n        return false;\n    }\n    for (const keyA in objA) {\n        if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Shallow compares two arrays\n * @param arrA\n * @param arrB\n * @return {boolean} - whether the arrays are shallow equal\n */\nexport function areArraysShallowEqualSameOrder(arrA, arrB) {\n    if (arrA.length !== arrB.length) {\n        return false;\n    }\n    for (let i = 0; i < arrA.length; i++) {\n        if (arrA[i] !== arrB[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","import {findWouldBeIndex, resetIndexesCache} from \"./listUtil\";\nimport {findCenterOfElement, isElementOffDocument} from \"./intersection\";\nimport {\n    dispatchDraggedElementEnteredContainer,\n    dispatchDraggedElementLeftContainerForAnother,\n    dispatchDraggedElementLeftContainerForNone,\n    dispatchDraggedLeftDocument,\n    dispatchDraggedElementIsOverIndex\n} from \"./dispatcher\";\nimport {makeScroller} from \"./scroller\";\nimport {getDepth} from \"./util\";\nimport {printDebug} from \"../constants\";\n\nconst INTERVAL_MS = 200;\nconst TOLERANCE_PX = 10;\nconst {scrollIfNeeded, resetScrolling} = makeScroller();\nlet next;\n\n/**\n * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)\n * @param {Set<HTMLElement>} dropZones\n * @param {HTMLElement} draggedEl\n * @param {number} [intervalMs = INTERVAL_MS]\n */\nexport function observe(draggedEl, dropZones, intervalMs = INTERVAL_MS) {\n    // initialization\n    let lastDropZoneFound;\n    let lastIndexFound;\n    let lastIsDraggedInADropZone = false;\n    let lastCentrePositionOfDragged;\n    // We are sorting to make sure that in case of nested zones of the same type the one \"on top\" is considered first\n    const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n\n    /**\n     * The main function in this module. Tracks where everything is/ should be a take the actions\n     */\n    function andNow() {\n        const currentCenterOfDragged = findCenterOfElement(draggedEl);\n        const scrolled = scrollIfNeeded(currentCenterOfDragged, lastDropZoneFound);\n        // we only want to make a new decision after the element was moved a bit to prevent flickering\n        if (\n            !scrolled &&\n            lastCentrePositionOfDragged &&\n            Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX &&\n            Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX\n        ) {\n            next = window.setTimeout(andNow, intervalMs);\n            return;\n        }\n        if (isElementOffDocument(draggedEl)) {\n            printDebug(() => \"off document\");\n            dispatchDraggedLeftDocument(draggedEl);\n            return;\n        }\n\n        lastCentrePositionOfDragged = currentCenterOfDragged;\n        // this is a simple algorithm, potential improvement: first look at lastDropZoneFound\n        let isDraggedInADropZone = false;\n        for (const dz of dropZonesFromDeepToShallow) {\n            const indexObj = findWouldBeIndex(draggedEl, dz);\n            if (indexObj === null) {\n                // it is not inside\n                continue;\n            }\n            const {index} = indexObj;\n            isDraggedInADropZone = true;\n            // the element is over a container\n            if (dz !== lastDropZoneFound) {\n                lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl, dz);\n                dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl);\n                lastDropZoneFound = dz;\n            } else if (index !== lastIndexFound) {\n                dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl);\n                lastIndexFound = index;\n            }\n            // we handle looping with the 'continue' statement above\n            break;\n        }\n        // the first time the dragged element is not in any dropzone we need to notify the last dropzone it was in\n        if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {\n            dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl);\n            lastDropZoneFound = undefined;\n            lastIndexFound = undefined;\n            lastIsDraggedInADropZone = false;\n        } else {\n            lastIsDraggedInADropZone = true;\n        }\n        next = window.setTimeout(andNow, intervalMs);\n    }\n    andNow();\n}\n\n// assumption - we can only observe one dragged element at a time, this could be changed in the future\nexport function unobserve() {\n    printDebug(() => \"unobserving\");\n    clearTimeout(next);\n    resetScrolling();\n    resetIndexesCache();\n}\n","import {makeScroller} from \"./scroller\";\nimport {printDebug} from \"../constants\";\n\nconst INTERVAL_MS = 300;\nlet mousePosition;\n\n/**\n * Do not use this! it is visible for testing only until we get over the issue Cypress not triggering the mousemove listeners\n * // TODO - make private (remove export)\n * @param {{clientX: number, clientY: number}} e\n */\nexport function updateMousePosition(e) {\n    const c = e.touches ? e.touches[0] : e;\n    mousePosition = {x: c.clientX, y: c.clientY};\n}\nconst {scrollIfNeeded, resetScrolling} = makeScroller();\nlet next;\n\nfunction loop() {\n    if (mousePosition) {\n        scrollIfNeeded(mousePosition, document.documentElement);\n    }\n    next = window.setTimeout(loop, INTERVAL_MS);\n}\n\n/**\n * will start watching the mouse pointer and scroll the window if it goes next to the edges\n */\nexport function armWindowScroller() {\n    printDebug(() => \"arming window scroller\");\n    window.addEventListener(\"mousemove\", updateMousePosition);\n    window.addEventListener(\"touchmove\", updateMousePosition);\n    loop();\n}\n\n/**\n * will stop watching the mouse pointer and won't scroll the window anymore\n */\nexport function disarmWindowScroller() {\n    printDebug(() => \"disarming window scroller\");\n    window.removeEventListener(\"mousemove\", updateMousePosition);\n    window.removeEventListener(\"touchmove\", updateMousePosition);\n    mousePosition = undefined;\n    window.clearTimeout(next);\n    resetScrolling();\n}\n","import {SHADOW_ELEMENT_ATTRIBUTE_NAME, DRAGGED_ELEMENT_ID} from \"../constants\";\nimport {findCenter} from \"./intersection\";\n\nconst TRANSITION_DURATION_SECONDS = 0.2;\n\n/**\n * private helper function - creates a transition string for a property\n * @param {string} property\n * @return {string} - the transition string\n */\nfunction trs(property) {\n    return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;\n}\n/**\n * clones the given element and applies proper styles and transitions to the dragged element\n * @param {HTMLElement} originalElement\n * @param {Point} [positionCenterOnXY]\n * @return {Node} - the cloned, styled element\n */\nexport function createDraggedElementFrom(originalElement, positionCenterOnXY) {\n    const rect = originalElement.getBoundingClientRect();\n    const draggedEl = originalElement.cloneNode(true);\n    copyStylesFromTo(originalElement, draggedEl);\n    draggedEl.id = DRAGGED_ELEMENT_ID;\n    draggedEl.style.position = \"fixed\";\n    let elTopPx = rect.top;\n    let elLeftPx = rect.left;\n    draggedEl.style.top = `${elTopPx}px`;\n    draggedEl.style.left = `${elLeftPx}px`;\n    if (positionCenterOnXY) {\n        const center = findCenter(rect);\n        elTopPx -= center.y - positionCenterOnXY.y;\n        elLeftPx -= center.x - positionCenterOnXY.x;\n        window.setTimeout(() => {\n            draggedEl.style.top = `${elTopPx}px`;\n            draggedEl.style.left = `${elLeftPx}px`;\n        }, 0);\n    }\n    draggedEl.style.margin = \"0\";\n    // we can't have relative or automatic height and width or it will break the illusion\n    draggedEl.style.boxSizing = \"border-box\";\n    draggedEl.style.height = `${rect.height}px`;\n    draggedEl.style.width = `${rect.width}px`;\n    draggedEl.style.transition = `${trs(\"top\")}, ${trs(\"left\")}, ${trs(\"background-color\")}, ${trs(\"opacity\")}, ${trs(\"color\")} `;\n    // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time\n    window.setTimeout(() => (draggedEl.style.transition += `, ${trs(\"width\")}, ${trs(\"height\")}`), 0);\n    draggedEl.style.zIndex = \"9999\";\n    draggedEl.style.cursor = \"grabbing\";\n\n    return draggedEl;\n}\n\n/**\n * styles the dragged element to a 'dropped' state\n * @param {HTMLElement} draggedEl\n */\nexport function moveDraggedElementToWasDroppedState(draggedEl) {\n    draggedEl.style.cursor = \"grab\";\n}\n\n/**\n * Morphs the dragged element style, maintains the mouse pointer within the element\n * @param {HTMLElement} draggedEl\n * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element\n * @param {number} currentMouseX\n * @param {number} currentMouseY\n * @param {function} transformDraggedElement - function to transform the dragged element, does nothing by default.\n */\nexport function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY, transformDraggedElement) {\n    const newRect = copyFromEl.getBoundingClientRect();\n    const draggedElRect = draggedEl.getBoundingClientRect();\n    const widthChange = newRect.width - draggedElRect.width;\n    const heightChange = newRect.height - draggedElRect.height;\n    if (widthChange || heightChange) {\n        const relativeDistanceOfMousePointerFromDraggedSides = {\n            left: (currentMouseX - draggedElRect.left) / draggedElRect.width,\n            top: (currentMouseY - draggedElRect.top) / draggedElRect.height\n        };\n        draggedEl.style.height = `${newRect.height}px`;\n        draggedEl.style.width = `${newRect.width}px`;\n        draggedEl.style.left = `${parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;\n        draggedEl.style.top = `${parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;\n    }\n\n    /// other properties\n    copyStylesFromTo(copyFromEl, draggedEl);\n    transformDraggedElement();\n}\n\n/**\n * @param {HTMLElement} copyFromEl\n * @param {HTMLElement} copyToEl\n */\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n    const computedStyle = window.getComputedStyle(copyFromEl);\n    Array.from(computedStyle)\n        .filter(\n            s =>\n                s.startsWith(\"background\") ||\n                s.startsWith(\"padding\") ||\n                s.startsWith(\"font\") ||\n                s.startsWith(\"text\") ||\n                s.startsWith(\"align\") ||\n                s.startsWith(\"justify\") ||\n                s.startsWith(\"display\") ||\n                s.startsWith(\"flex\") ||\n                s.startsWith(\"border\") ||\n                s === \"opacity\" ||\n                s === \"color\" ||\n                s === \"list-style-type\"\n        )\n        .forEach(s => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));\n}\n\n/**\n * makes the element compatible with being draggable\n * @param {HTMLElement} draggableEl\n * @param {boolean} dragDisabled\n */\nexport function styleDraggable(draggableEl, dragDisabled) {\n    draggableEl.draggable = false;\n    draggableEl.ondragstart = () => false;\n    if (!dragDisabled) {\n        draggableEl.style.userSelect = \"none\";\n        draggableEl.style.WebkitUserSelect = \"none\";\n        draggableEl.style.cursor = \"grab\";\n    } else {\n        draggableEl.style.userSelect = \"\";\n        draggableEl.style.WebkitUserSelect = \"\";\n        draggableEl.style.cursor = \"\";\n    }\n}\n\n/**\n * Hides the provided element so that it can stay in the dom without interrupting\n * @param {HTMLElement} dragTarget\n */\nexport function hideOriginalDragTarget(dragTarget) {\n    dragTarget.style.display = \"none\";\n    dragTarget.style.position = \"fixed\";\n    dragTarget.style.zIndex = \"-5\";\n}\n\n/**\n * styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function decorateShadowEl(shadowEl) {\n    shadowEl.style.visibility = \"hidden\";\n    shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n}\n\n/**\n * undo the styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function unDecorateShadowElement(shadowEl) {\n    shadowEl.style.visibility = \"\";\n    shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n\n/**\n * will mark the given dropzones as visually active\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleActiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = styles[style];\n        });\n        getClasses(dz).forEach(c => dz.classList.add(c));\n    });\n}\n\n/**\n * will remove the 'active' styling from given dropzones\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleInactiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = \"\";\n        });\n        getClasses(dz).forEach(c => dz.classList.contains(c) && dz.classList.remove(c));\n    });\n}\n\n/**\n * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values\n * @param {HTMLElement} el\n * @return {function(): void} - run this function to undo the operation and restore the original values\n */\nexport function preventShrinking(el) {\n    const originalMinHeight = el.style.minHeight;\n    el.style.minHeight = window.getComputedStyle(el).getPropertyValue(\"height\");\n    const originalMinWidth = el.style.minWidth;\n    el.style.minWidth = window.getComputedStyle(el).getPropertyValue(\"width\");\n    return function undo() {\n        el.style.minHeight = originalMinHeight;\n        el.style.minWidth = originalMinWidth;\n    };\n}\n","import {\n    decrementActiveDropZoneCount,\n    incrementActiveDropZoneCount,\n    ITEM_ID_KEY,\n    printDebug,\n    SHADOW_ITEM_MARKER_PROPERTY_NAME,\n    SHADOW_PLACEHOLDER_ITEM_ID,\n    SOURCES,\n    TRIGGERS\n} from \"./constants\";\nimport {observe, unobserve} from \"./helpers/observer\";\nimport {armWindowScroller, disarmWindowScroller} from \"./helpers/windowScroller\";\nimport {\n    createDraggedElementFrom,\n    decorateShadowEl,\n    hideOriginalDragTarget,\n    morphDraggedElementToBeLike,\n    moveDraggedElementToWasDroppedState,\n    preventShrinking,\n    styleActiveDropZones,\n    styleDraggable,\n    styleInactiveDropZones,\n    unDecorateShadowElement\n} from \"./helpers/styler\";\nimport {\n    dispatchConsiderEvent,\n    dispatchFinalizeEvent,\n    DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_LEFT_DOCUMENT_EVENT_NAME,\n    DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_TYPES,\n    DRAGGED_OVER_INDEX_EVENT_NAME\n} from \"./helpers/dispatcher\";\nimport {areArraysShallowEqualSameOrder, areObjectsShallowEqual, toString} from \"./helpers/util\";\nimport {getBoundingRectNoTransforms} from \"./helpers/intersection\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst MIN_OBSERVATION_INTERVAL_MS = 100;\nconst MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet originalDragTarget;\nlet draggedEl;\nlet draggedElData;\nlet draggedElType;\nlet originDropZone;\nlet originIndex;\nlet shadowElData;\nlet shadowElDropZone;\nlet dragStartMousePosition;\nlet currentMousePosition;\nlet isWorkingOnPreviousDrag = false;\nlet finalizingPreviousDrag = false;\nlet unlockOriginDzMinDimensions;\nlet isDraggedOutsideOfAnyDz = false;\n\n// a map from type to a set of drop-zones\nconst typeToDropZones = new Map();\n// important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners\nconst dzToConfig = new Map();\n// this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)\nconst elToMouseDownListener = new WeakMap();\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n}\n\n/* functions to manage observing the dragged element and trigger custom drag-events */\nfunction watchDraggedElement() {\n    printDebug(() => \"watching dragged element\");\n    armWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth\n    const observationIntervalMs = Math.max(\n        MIN_OBSERVATION_INTERVAL_MS,\n        ...Array.from(dropZones.keys()).map(dz => dzToConfig.get(dz).dropAnimationDurationMs)\n    );\n    observe(draggedEl, dropZones, observationIntervalMs * 1.07);\n}\nfunction unWatchDraggedElement() {\n    printDebug(() => \"unwatching dragged element\");\n    disarmWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    unobserve();\n}\n\n// finds the initial placeholder that is placed there on drag start\nfunction findShadowPlaceHolderIdx(items) {\n    return items.findIndex(item => item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID);\n}\nfunction findShadowElementIdx(items) {\n    // checking that the id is not the placeholder's for Dragula like usecases\n    return items.findIndex(item => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID);\n}\n\n/* custom drag-events handlers */\nfunction handleDraggedEntered(e) {\n    printDebug(() => [\"dragged entered\", e.currentTarget, e.detail]);\n    let {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"ignoring dragged entered because drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    // this deals with another race condition. in rare occasions (super rapid operations) the list hasn't updated yet\n    items = items.filter(item => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);\n    printDebug(() => `dragged entered items ${toString(items)}`);\n\n    if (originDropZone !== e.currentTarget) {\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        const newOriginZoneItems = originZoneItems.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n        dispatchConsiderEvent(originDropZone, newOriginZoneItems, {\n            trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    } else {\n        const shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);\n        if (shadowPlaceHolderIdx !== -1) {\n            // only happens right after drag start, on the first drag entered event\n            printDebug(() => \"removing placeholder item from origin dz\");\n            items.splice(shadowPlaceHolderIdx, 1);\n        }\n    }\n\n    const {index, isProximityBased} = e.detail.indexObj;\n    const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;\n    shadowElDropZone = e.currentTarget;\n    items.splice(shadowElIdx, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\nfunction handleDraggedLeft(e) {\n    // dealing with a rare race condition on extremely rapid clicking and dropping\n    if (!isWorkingOnPreviousDrag) return;\n    printDebug(() => [\"dragged left\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const shadowElIdx = findShadowElementIdx(items);\n    const shadowItem = items.splice(shadowElIdx, 1)[0];\n    shadowElDropZone = undefined;\n    const {type, theOtherDz} = e.detail;\n    if (\n        type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY ||\n        (type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled)\n    ) {\n        printDebug(() => \"dragged left all, putting shadow element back in the origin dz\");\n        isDraggedOutsideOfAnyDz = true;\n        shadowElDropZone = originDropZone;\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        originZoneItems.splice(originIndex, 0, shadowItem);\n        dispatchConsiderEvent(originDropZone, originZoneItems, {\n            trigger: TRIGGERS.DRAGGED_LEFT_ALL,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity\n    dispatchConsiderEvent(e.currentTarget, items, {\n        trigger: TRIGGERS.DRAGGED_LEFT,\n        id: draggedElData[ITEM_ID_KEY],\n        source: SOURCES.POINTER\n    });\n}\nfunction handleDraggedIsOverIndex(e) {\n    printDebug(() => [\"dragged is over index\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    const {index} = e.detail.indexObj;\n    const shadowElIdx = findShadowElementIdx(items);\n    items.splice(shadowElIdx, 1);\n    items.splice(index, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\n// Global mouse/touch-events handlers\nfunction handleMouseMove(e) {\n    e.preventDefault();\n    const c = e.touches ? e.touches[0] : e;\n    currentMousePosition = {x: c.clientX, y: c.clientY};\n    draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${\n        currentMousePosition.y - dragStartMousePosition.y\n    }px, 0)`;\n}\n\nfunction handleDrop() {\n    printDebug(() => \"dropped\");\n    finalizingPreviousDrag = true;\n    // cleanup\n    window.removeEventListener(\"mousemove\", handleMouseMove);\n    window.removeEventListener(\"touchmove\", handleMouseMove);\n    window.removeEventListener(\"mouseup\", handleDrop);\n    window.removeEventListener(\"touchend\", handleDrop);\n    unWatchDraggedElement();\n    moveDraggedElementToWasDroppedState(draggedEl);\n\n    if (!shadowElDropZone) {\n        printDebug(() => \"element was dropped right after it left origin but before entering somewhere else\");\n        shadowElDropZone = originDropZone;\n    }\n    printDebug(() => [\"dropped in dz\", shadowElDropZone]);\n    let {items, type} = dzToConfig.get(shadowElDropZone);\n    styleInactiveDropZones(\n        typeToDropZones.get(type),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    let shadowElIdx = findShadowElementIdx(items);\n    // the handler might remove the shadow element, ex: dragula like copy on drag\n    if (shadowElIdx === -1) shadowElIdx = originIndex;\n    items = items.map(item => (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item));\n    function finalizeWithinZone() {\n        unlockOriginDzMinDimensions();\n        dispatchFinalizeEvent(shadowElDropZone, items, {\n            trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n        if (shadowElDropZone !== originDropZone) {\n            // letting the origin drop zone know the element was permanently taken away\n            dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {\n                trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n                id: draggedElData[ITEM_ID_KEY],\n                source: SOURCES.POINTER\n            });\n        }\n        unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);\n        cleanupPostDrop();\n    }\n    animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);\n}\n\n// helper function for handleDrop\nfunction animateDraggedToFinalPosition(shadowElIdx, callback) {\n    const shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);\n    const newTransform = {\n        x: shadowElRect.left - parseFloat(draggedEl.style.left),\n        y: shadowElRect.top - parseFloat(draggedEl.style.top)\n    };\n    const {dropAnimationDurationMs} = dzToConfig.get(shadowElDropZone);\n    const transition = `transform ${dropAnimationDurationMs}ms ease`;\n    draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + \",\" + transition : transition;\n    draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;\n    window.setTimeout(callback, dropAnimationDurationMs);\n}\n\n/* cleanup */\nfunction cleanupPostDrop() {\n    draggedEl.remove();\n    originalDragTarget.remove();\n    draggedEl = undefined;\n    originalDragTarget = undefined;\n    draggedElData = undefined;\n    draggedElType = undefined;\n    originDropZone = undefined;\n    originIndex = undefined;\n    shadowElData = undefined;\n    shadowElDropZone = undefined;\n    dragStartMousePosition = undefined;\n    currentMousePosition = undefined;\n    isWorkingOnPreviousDrag = false;\n    finalizingPreviousDrag = false;\n    unlockOriginDzMinDimensions = undefined;\n    isDraggedOutsideOfAnyDz = false;\n}\n\nexport function dndzone(node, options) {\n    const config = {\n        items: undefined,\n        type: undefined,\n        flipDurationMs: 0,\n        dragDisabled: false,\n        morphDisabled: false,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        transformDraggedElement: () => {},\n        centreDraggedOnCursor: false\n    };\n    printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, {node}]);\n    let elToIdx = new Map();\n\n    function addMaybeListeners() {\n        window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleFalseAlarm, {passive: false});\n        window.addEventListener(\"touchend\", handleFalseAlarm, {passive: false});\n    }\n    function removeMaybeListeners() {\n        window.removeEventListener(\"mousemove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"touchmove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"mouseup\", handleFalseAlarm);\n        window.removeEventListener(\"touchend\", handleFalseAlarm);\n    }\n    function handleFalseAlarm() {\n        removeMaybeListeners();\n        originalDragTarget = undefined;\n        dragStartMousePosition = undefined;\n        currentMousePosition = undefined;\n    }\n\n    function handleMouseMoveMaybeDragStart(e) {\n        e.preventDefault();\n        const c = e.touches ? e.touches[0] : e;\n        currentMousePosition = {x: c.clientX, y: c.clientY};\n        if (\n            Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n            Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n        ) {\n            removeMaybeListeners();\n            handleDragStart();\n        }\n    }\n    function handleMouseDown(e) {\n        // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense\n        if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {\n            printDebug(() => \"won't initiate drag on a nested input element\");\n            return;\n        }\n        // prevents responding to any button but left click which equals 0 (which is falsy)\n        if (e.button) {\n            printDebug(() => `ignoring none left click button: ${e.button}`);\n            return;\n        }\n        if (isWorkingOnPreviousDrag) {\n            printDebug(() => \"cannot start a new drag before finalizing previous one\");\n            return;\n        }\n        e.stopPropagation();\n        const c = e.touches ? e.touches[0] : e;\n        dragStartMousePosition = {x: c.clientX, y: c.clientY};\n        currentMousePosition = {...dragStartMousePosition};\n        originalDragTarget = e.currentTarget;\n        addMaybeListeners();\n    }\n\n    function handleDragStart() {\n        printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);\n        isWorkingOnPreviousDrag = true;\n\n        // initialising globals\n        const currentIdx = elToIdx.get(originalDragTarget);\n        originIndex = currentIdx;\n        originDropZone = originalDragTarget.parentElement;\n        /** @type {ShadowRoot | HTMLDocument} */\n        const rootNode = originDropZone.getRootNode();\n        const originDropZoneRoot = rootNode.body || rootNode;\n        const {items, type, centreDraggedOnCursor} = config;\n        draggedElData = {...items[currentIdx]};\n        draggedElType = type;\n        shadowElData = {...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true};\n        // The initial shadow element. We need a different id at first in order to avoid conflicts and timing issues\n        const placeHolderElData = {...shadowElData, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID};\n\n        // creating the draggable element\n        draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);\n        // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it\n        function keepOriginalElementInDom() {\n            if (!draggedEl.parentElement) {\n                originDropZoneRoot.appendChild(draggedEl);\n                // to prevent the outline from disappearing\n                draggedEl.focus();\n                watchDraggedElement();\n                hideOriginalDragTarget(originalDragTarget);\n                originDropZoneRoot.appendChild(originalDragTarget);\n            } else {\n                window.requestAnimationFrame(keepOriginalElementInDom);\n            }\n        }\n        window.requestAnimationFrame(keepOriginalElementInDom);\n\n        styleActiveDropZones(\n            Array.from(typeToDropZones.get(config.type)).filter(dz => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n\n        // removing the original element by removing its data entry\n        items.splice(currentIdx, 1, placeHolderElData);\n        unlockOriginDzMinDimensions = preventShrinking(originDropZone);\n\n        dispatchConsiderEvent(originDropZone, items, {trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n\n        // handing over to global handlers - starting to watch the element\n        window.addEventListener(\"mousemove\", handleMouseMove, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMove, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleDrop, {passive: false});\n        window.addEventListener(\"touchend\", handleDrop, {passive: false});\n    }\n\n    function configure({\n        items = undefined,\n        flipDurationMs: dropAnimationDurationMs = 0,\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        morphDisabled = false,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        transformDraggedElement = () => {},\n        centreDraggedOnCursor = false\n    }) {\n        config.dropAnimationDurationMs = dropAnimationDurationMs;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.morphDisabled = morphDisabled;\n        config.transformDraggedElement = transformDraggedElement;\n        config.centreDraggedOnCursor = centreDraggedOnCursor;\n\n        // realtime update for dropTargetStyle\n        if (\n            isWorkingOnPreviousDrag &&\n            !finalizingPreviousDrag &&\n            (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) ||\n                !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))\n        ) {\n            styleInactiveDropZones(\n                [node],\n                () => config.dropTargetStyle,\n                () => dropTargetClasses\n            );\n            styleActiveDropZones(\n                [node],\n                () => dropTargetStyle,\n                () => dropTargetClasses\n            );\n        }\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = [...dropTargetClasses];\n\n        // realtime update for dropFromOthersDisabled\n        function getConfigProp(dz, propName) {\n            return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];\n        }\n        if (isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {\n            if (dropFromOthersDisabled) {\n                styleInactiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            } else {\n                styleActiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            }\n        }\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n\n        dzToConfig.set(node, config);\n        const shadowElIdx = findShadowElementIdx(config.items);\n        for (let idx = 0; idx < node.children.length; idx++) {\n            const draggableEl = node.children[idx];\n            styleDraggable(draggableEl, dragDisabled);\n            if (idx === shadowElIdx) {\n                if (!morphDisabled) {\n                    morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y, () =>\n                        config.transformDraggedElement(draggedEl, draggedElData, idx)\n                    );\n                }\n                decorateShadowEl(draggableEl);\n                continue;\n            }\n            draggableEl.removeEventListener(\"mousedown\", elToMouseDownListener.get(draggableEl));\n            draggableEl.removeEventListener(\"touchstart\", elToMouseDownListener.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"mousedown\", handleMouseDown);\n                draggableEl.addEventListener(\"touchstart\", handleMouseDown);\n                elToMouseDownListener.set(draggableEl, handleMouseDown);\n            }\n            // updating the idx\n            elToIdx.set(draggableEl, idx);\n        }\n    }\n    configure(options);\n\n    return {\n        update: newOptions => {\n            printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            printDebug(() => \"pointer dndzone will destroy\");\n            unregisterDropZone(node, config.type);\n            dzToConfig.delete(node);\n        }\n    };\n}\n","import {isOnServer} from \"../constants\";\n\nconst INSTRUCTION_IDs = {\n    DND_ZONE_ACTIVE: \"dnd-zone-active\",\n    DND_ZONE_DRAG_DISABLED: \"dnd-zone-drag-disabled\"\n};\nconst ID_TO_INSTRUCTION = {\n    [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: \"Tab to one the items and press space-bar or enter to start dragging it\",\n    [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: \"This is a disabled drag and drop list\"\n};\n\nconst ALERT_DIV_ID = \"dnd-action-aria-alert\";\nlet alertsDiv;\n\nfunction initAriaOnBrowser() {\n    // setting the dynamic alerts\n    alertsDiv = document.createElement(\"div\");\n    (function initAlertsDiv() {\n        alertsDiv.id = ALERT_DIV_ID;\n        // tab index -1 makes the alert be read twice on chrome for some reason\n        //alertsDiv.tabIndex = -1;\n        alertsDiv.style.position = \"fixed\";\n        alertsDiv.style.bottom = \"0\";\n        alertsDiv.style.left = \"0\";\n        alertsDiv.style.zIndex = \"-5\";\n        alertsDiv.style.opacity = \"0\";\n        alertsDiv.style.height = \"0\";\n        alertsDiv.style.width = \"0\";\n        alertsDiv.setAttribute(\"role\", \"alert\");\n    })();\n    document.body.prepend(alertsDiv);\n\n    // setting the instructions\n    Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));\n}\n\n/**\n * Initializes the static aria instructions so they can be attached to zones\n * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server\n */\nexport function initAria() {\n    if (isOnServer) return null;\n    if (document.readyState === \"complete\") {\n        initAriaOnBrowser();\n    } else {\n        window.addEventListener(\"DOMContentLoaded\", initAriaOnBrowser);\n    }\n    return {...INSTRUCTION_IDs};\n}\nfunction instructionToHiddenDiv(id, txt) {\n    const div = document.createElement(\"div\");\n    div.id = id;\n    div.innerHTML = `<p>${txt}</p>`;\n    div.style.display = \"none\";\n    div.style.position = \"fixed\";\n    div.style.zIndex = \"-5\";\n    return div;\n}\n\n/**\n * Will make the screen reader alert the provided text to the user\n * @param {string} txt\n */\nexport function alertToScreenReader(txt) {\n    alertsDiv.innerHTML = \"\";\n    const alertText = document.createTextNode(txt);\n    alertsDiv.appendChild(alertText);\n    // this is needed for Safari\n    alertsDiv.style.display = \"none\";\n    alertsDiv.style.display = \"inline\";\n}\n","import {decrementActiveDropZoneCount, incrementActiveDropZoneCount, ITEM_ID_KEY, SOURCES, TRIGGERS} from \"./constants\";\nimport {styleActiveDropZones, styleInactiveDropZones} from \"./helpers/styler\";\nimport {dispatchConsiderEvent, dispatchFinalizeEvent} from \"./helpers/dispatcher\";\nimport {initAria, alertToScreenReader} from \"./helpers/aria\";\nimport {toString} from \"./helpers/util\";\nimport {printDebug} from \"./constants\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet isDragging = false;\nlet draggedItemType;\nlet focusedDz;\nlet focusedDzLabel = \"\";\nlet focusedItem;\nlet focusedItemId;\nlet focusedItemLabel = \"\";\nconst allDragTargets = new WeakSet();\nconst elToKeyDownListeners = new WeakMap();\nconst elToFocusListeners = new WeakMap();\nconst dzToHandles = new Map();\nconst dzToConfig = new Map();\nconst typeToDropZones = new Map();\n\n/* TODO (potentially)\n * what's the deal with the black border of voice-reader not following focus?\n * maybe keep focus on the last dragged item upon drop?\n */\n\nconst INSTRUCTION_IDs = initAria();\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"adding global keydown and click handlers\");\n        window.addEventListener(\"keydown\", globalKeyDownHandler);\n        window.addEventListener(\"click\", globalClickHandler);\n    }\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    printDebug(() => \"unregistering drop-zone\");\n    if (focusedDz === dropZoneEl) {\n        handleDrop();\n    }\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"removing global keydown and click handlers\");\n        window.removeEventListener(\"keydown\", globalKeyDownHandler);\n        window.removeEventListener(\"click\", globalClickHandler);\n    }\n}\n\nfunction globalKeyDownHandler(e) {\n    if (!isDragging) return;\n    switch (e.key) {\n        case \"Escape\": {\n            handleDrop();\n            break;\n        }\n    }\n}\n\nfunction globalClickHandler() {\n    if (!isDragging) return;\n    if (!allDragTargets.has(document.activeElement)) {\n        printDebug(() => \"clicked outside of any draggable\");\n        handleDrop();\n    }\n}\n\nfunction handleZoneFocus(e) {\n    printDebug(() => \"zone focus\");\n    if (!isDragging) return;\n    const newlyFocusedDz = e.currentTarget;\n    if (newlyFocusedDz === focusedDz) return;\n\n    focusedDzLabel = newlyFocusedDz.getAttribute(\"aria-label\") || \"\";\n    const {items: originItems} = dzToConfig.get(focusedDz);\n    const originItem = originItems.find(item => item[ITEM_ID_KEY] === focusedItemId);\n    const originIdx = originItems.indexOf(originItem);\n    const itemToMove = originItems.splice(originIdx, 1)[0];\n    const {items: targetItems, autoAriaDisabled} = dzToConfig.get(newlyFocusedDz);\n    if (\n        newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top ||\n        newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left\n    ) {\n        targetItems.push(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);\n        }\n    } else {\n        targetItems.unshift(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);\n        }\n    }\n    const dzFrom = focusedDz;\n    dispatchFinalizeEvent(dzFrom, originItems, {trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD});\n    dispatchFinalizeEvent(newlyFocusedDz, targetItems, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n    focusedDz = newlyFocusedDz;\n}\n\nfunction triggerAllDzsUpdate() {\n    dzToHandles.forEach(({update}, dz) => update(dzToConfig.get(dz)));\n}\n\nfunction handleDrop(dispatchConsider = true) {\n    printDebug(() => \"drop\");\n    if (!dzToConfig.get(focusedDz).autoAriaDisabled) {\n        alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);\n    }\n    if (allDragTargets.has(document.activeElement)) {\n        document.activeElement.blur();\n    }\n    if (dispatchConsider) {\n        dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {\n            trigger: TRIGGERS.DRAG_STOPPED,\n            id: focusedItemId,\n            source: SOURCES.KEYBOARD\n        });\n    }\n    styleInactiveDropZones(\n        typeToDropZones.get(draggedItemType),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    focusedItem = null;\n    focusedItemId = null;\n    focusedItemLabel = \"\";\n    draggedItemType = null;\n    focusedDz = null;\n    focusedDzLabel = \"\";\n    isDragging = false;\n    triggerAllDzsUpdate();\n}\n//////\nexport function dndzone(node, options) {\n    const config = {\n        items: undefined,\n        type: undefined,\n        dragDisabled: false,\n        zoneTabIndex: 0,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        autoAriaDisabled: false\n    };\n\n    function swap(arr, i, j) {\n        if (arr.length <= 1) return;\n        arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);\n    }\n\n    function handleKeyDown(e) {\n        printDebug(() => [\"handling key down\", e.key]);\n        switch (e.key) {\n            case \"Enter\":\n            case \" \": {\n                // we don't want to affect nested input elements or clickable elements\n                if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {\n                    return;\n                }\n                e.preventDefault(); // preventing scrolling on spacebar\n                e.stopPropagation();\n                if (isDragging) {\n                    // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?\n                    handleDrop();\n                } else {\n                    // drag start\n                    handleDragStart(e);\n                }\n                break;\n            }\n            case \"ArrowDown\":\n            case \"ArrowRight\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow down\", idx]);\n                if (idx < children.length - 1) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx + 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowLeft\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow up\", idx]);\n                if (idx > 0) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx - 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n        }\n    }\n    function handleDragStart(e) {\n        printDebug(() => \"drag start\");\n        setCurrentFocusedItem(e.currentTarget);\n        focusedDz = node;\n        draggedItemType = config.type;\n        isDragging = true;\n        const dropTargets = Array.from(typeToDropZones.get(config.type)).filter(dz => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);\n        styleActiveDropZones(\n            dropTargets,\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n        if (!config.autoAriaDisabled) {\n            let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;\n            if (dropTargets.length > 1) {\n                msg += `, or tab to another list in order to move the item into it`;\n            }\n            alertToScreenReader(msg);\n        }\n        dispatchConsiderEvent(node, dzToConfig.get(node).items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});\n        triggerAllDzsUpdate();\n    }\n\n    function handleClick(e) {\n        if (!isDragging) return;\n        if (e.currentTarget === focusedItem) return;\n        e.stopPropagation();\n        handleDrop(false);\n        handleDragStart(e);\n    }\n    function setCurrentFocusedItem(draggableEl) {\n        const {items} = dzToConfig.get(node);\n        const children = Array.from(node.children);\n        const focusedItemIdx = children.indexOf(draggableEl);\n        focusedItem = draggableEl;\n        focusedItem.tabIndex = 0;\n        focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];\n        focusedItemLabel = children[focusedItemIdx].getAttribute(\"aria-label\") || \"\";\n    }\n\n    function configure({\n        items = [],\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        zoneTabIndex = 0,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        autoAriaDisabled = false\n    }) {\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n        config.zoneTabIndex = zoneTabIndex;\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = dropTargetClasses;\n        config.autoAriaDisabled = autoAriaDisabled;\n        if (!autoAriaDisabled) {\n            node.setAttribute(\"aria-disabled\", dragDisabled);\n            node.setAttribute(\"role\", \"list\");\n            node.setAttribute(\"aria-describedby\", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);\n        }\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        dzToConfig.set(node, config);\n\n        if (isDragging) {\n            node.tabIndex =\n                node === focusedDz ||\n                focusedItem.contains(node) ||\n                config.dropFromOthersDisabled ||\n                (focusedDz && config.type !== dzToConfig.get(focusedDz).type)\n                ? -1\n                : 0;\n        } else {\n            node.tabIndex = config.zoneTabIndex;\n        }\n\n        node.addEventListener(\"focus\", handleZoneFocus);\n\n        for (let i = 0; i < node.children.length; i++) {\n            const draggableEl = node.children[i];\n            allDragTargets.add(draggableEl);\n            draggableEl.tabIndex = isDragging ? -1 : 0;\n            if (!autoAriaDisabled) {\n                draggableEl.setAttribute(\"role\", \"listitem\");\n            }\n            draggableEl.removeEventListener(\"keydown\", elToKeyDownListeners.get(draggableEl));\n            draggableEl.removeEventListener(\"click\", elToFocusListeners.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"keydown\", handleKeyDown);\n                elToKeyDownListeners.set(draggableEl, handleKeyDown);\n                draggableEl.addEventListener(\"click\", handleClick);\n                elToFocusListeners.set(draggableEl, handleClick);\n            }\n            if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {\n                printDebug(() => [\"focusing on\", {i, focusedItemId}]);\n                // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer\n                focusedItem = draggableEl;\n                focusedItem.tabIndex = 0;\n                // without this the element loses focus if it moves backwards in the list\n                draggableEl.focus();\n            }\n        }\n    }\n    configure(options);\n\n    const handles = {\n        update: newOptions => {\n            printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            printDebug(() => \"keyboard dndzone will destroy\");\n            unregisterDropZone(node, config.type);\n            dzToConfig.delete(node);\n            dzToHandles.delete(node);\n        }\n    };\n    dzToHandles.set(node, handles);\n    return handles;\n}\n","import {dndzone as pointerDndZone} from \"./pointerAction\";\nimport {dndzone as keyboardDndZone} from \"./keyboardAction\";\nimport {ITEM_ID_KEY} from \"./constants\";\nimport {toString} from \"./helpers/util\";\n\n/**\n * A custom action to turn any container to a dnd zone and all of its direct children to draggables\n * Supports mouse, touch and keyboard interactions.\n * Dispatches two events that the container is expected to react to by modifying its list of items,\n * which will then feed back in to this action via the update function\n *\n * @typedef {object} Options\n * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block\n * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type\n * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero\n * @property {boolean} [dragDisabled]\n * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions\n * @property {boolean} [dropFromOthersDisabled]\n * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging\n * @property {object} [dropTargetStyle]\n * @property {string[]} [dropTargetClasses]\n * @property {function} [transformDraggedElement]\n * @param {HTMLElement} node - the element to enhance\n * @param {Options} options\n * @return {{update: function, destroy: function}}\n */\nexport function dndzone(node, options) {\n    validateOptions(options);\n    const pointerZone = pointerDndZone(node, options);\n    const keyboardZone = keyboardDndZone(node, options);\n    return {\n        update: newOptions => {\n            validateOptions(newOptions);\n            pointerZone.update(newOptions);\n            keyboardZone.update(newOptions);\n        },\n        destroy: () => {\n            pointerZone.destroy();\n            keyboardZone.destroy();\n        }\n    };\n}\n\nfunction validateOptions(options) {\n    /*eslint-disable*/\n    const {\n        items,\n        flipDurationMs,\n        type,\n        dragDisabled,\n        morphDisabled,\n        dropFromOthersDisabled,\n        zoneTabIndex,\n        dropTargetStyle,\n        dropTargetClasses,\n        transformDraggedElement,\n        autoAriaDisabled,\n        centreDraggedOnCursor,\n        ...rest\n    } = options;\n    /*eslint-enable*/\n    if (Object.keys(rest).length > 0) {\n        console.warn(`dndzone will ignore unknown options`, rest);\n    }\n    if (!items) {\n        throw new Error(\"no 'items' key provided to dndzone\");\n    }\n    const itemWithMissingId = items.find(item => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));\n    if (itemWithMissingId) {\n        throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);\n    }\n    if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {\n        throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);\n    }\n    if (zoneTabIndex && !isInt(zoneTabIndex)) {\n        throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);\n    }\n}\n\nfunction isInt(value) {\n    return !isNaN(value) && (function(x) { return (x | 0) === x; })(parseFloat(value));\n}\n","<script>\r\n\timport { bookmarks } from \"./stores\";\r\n\texport let link, groupIndex, setIndex, linkIndex;\r\n\tlet titleEditable = false;\r\n\tlet newTitle;\r\n\r\n\tfunction del() {\r\n\t\t$bookmarks[groupIndex].sets[setIndex].contents.splice(linkIndex, 1);\r\n\t\t$bookmarks = $bookmarks;\r\n\t}\r\n\tfunction edit() {\r\n\t\ttitleEditable = true;\r\n\t\tnewTitle = link.title;\r\n\t}\r\n\tfunction updateTitle() {\r\n\t\ttitleEditable = false;\r\n\t\t$bookmarks[groupIndex].sets[setIndex].contents[linkIndex].title =\r\n\t\t\tnewTitle;\r\n\t}\r\n</script>\r\n\r\n<slot>\r\n\t{#if typeof link !== \"undefined\" && link.display}\r\n\t\t<section class=\"link\">\r\n\t\t\t{#if !titleEditable}\r\n\t\t\t\t<a href={link.url} target=\"_blank\">{link.title}</a>\r\n\t\t\t\t<span class=\"editLink\" on:click={edit}\r\n\t\t\t\t\t><svg\r\n\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\r\n\t\t\t\t\t\twidth=\"16\"\r\n\t\t\t\t\t\theight=\"16\"\r\n\t\t\t\t\t\tviewBox=\"0 0 24 24\"\r\n\t\t\t\t\t\tfill=\"none\"\r\n\t\t\t\t\t\tstroke=\"#666\"\r\n\t\t\t\t\t\tstroke-width=\"2\"\r\n\t\t\t\t\t\tstroke-linecap=\"round\"\r\n\t\t\t\t\t\tstroke-linejoin=\"round\"\r\n\t\t\t\t\t\t><circle cx=\"12\" cy=\"12\" r=\"3\" /><path\r\n\t\t\t\t\t\t\td=\"M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z\"\r\n\t\t\t\t\t\t/></svg\r\n\t\t\t\t\t></span\r\n\t\t\t\t>\r\n\t\t\t{:else}\r\n\t\t\t\t<input class=\"linkEditMode\" bind:value={newTitle} />\r\n\t\t\t\t<button on:click={updateTitle}>update</button>\r\n\t\t\t\t<button on:click={del}>delete</button>\r\n\t\t\t{/if}\r\n\t\t</section>\r\n\t{/if}\r\n</slot>\r\n\r\n<style>\r\n\tsection.link {\r\n\t\tmargin-bottom: 10px;\r\n\t}\r\n\t.editLink {\r\n\t\tcursor: pointer;\r\n\t\tdisplay: inline-block;\r\n\t\tmargin-left: 5px;\r\n\t}\r\n\t.linkEditMode {\r\n\t\twidth: 100%;\r\n\t\tborder: 1px solid #ccc;\r\n\t}\r\n</style>\r\n","<script>\r\n\texport let set, setIndex, groupIndex;\r\n\timport Link from \"./Link.svelte\";\r\n\timport { appState, bookmarks } from \"./stores\";\r\n\timport { dndzone } from \"svelte-dnd-action\";\r\n\r\n\tlet items;\r\n\tlet newTitle;\r\n\tlet editMode = false;\r\n\r\n\t/*OK guys, this line is critical; refactoring set.contents as items worked up to a point; but without using this operator, changes to $bookmarks were not forcing changes to items, so no updates occured on filter, for example */\r\n\t$: items = set.contents;\r\n\r\n\tfunction handleDndConsider(e) {\r\n\t\titems = e.detail.items;\r\n\t\tconsole.log(set.id);\r\n\t\t$bookmarks[groupIndex].sets[setIndex].contents = e.detail.items;\r\n\t}\r\n\r\n\tfunction handleDndFinalize(e) {\r\n\t\titems = e.detail.items;\r\n\t\t$bookmarks[groupIndex].sets[setIndex].contents = e.detail.items;\r\n\t}\r\n\r\n\tfunction edit() {\r\n\t\teditMode = true;\r\n\t\tnewTitle = set.title;\r\n\t}\r\n\r\n\tfunction updateTitle() {\r\n\t\teditMode = false;\r\n\t\t$bookmarks[groupIndex].sets[setIndex].title = newTitle;\r\n\t}\r\n\r\n\tfunction del() {\r\n\t\teditMode = false;\r\n\t\t$bookmarks[groupIndex].sets.splice(setIndex, 1);\r\n\t\t$bookmarks = $bookmarks;\r\n\t}\r\n\r\n\tfunction moveSet(newGroupIndex) {\r\n\t\teditMode = false;\r\n\t\tconsole.log(\"move set \" + setIndex + \" to \" + newGroupIndex);\r\n\t\tlet movedSet = $bookmarks[groupIndex].sets.splice(setIndex, 1);\r\n\t\tconsole.log(movedSet);\r\n\t\t$bookmarks[newGroupIndex].sets.unshift(movedSet[0]);\r\n\t\tconsole.log($bookmarks[newGroupIndex]);\r\n\t\t$bookmarks = $bookmarks;\r\n\t}\r\n</script>\r\n\r\n<slot>\r\n\t<section class=\"setContainer\" data-set-id={set.id}>\r\n\t\t<section class=\"setHeader\">\r\n\t\t\t{#if !editMode}\r\n\t\t\t\t<h2>\r\n\t\t\t\t\t{set.title}\r\n\t\t\t\t\t{#if !(groupIndex == 0 && setIndex == 0)}<span\r\n\t\t\t\t\t\t\tclass=\"setControls\"\r\n\t\t\t\t\t\t\ton:click={edit}\r\n\t\t\t\t\t\t\t><span class=\"editLink\" on:click={edit}\r\n\t\t\t\t\t\t\t\t><svg\r\n\t\t\t\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\r\n\t\t\t\t\t\t\t\t\twidth=\"20\"\r\n\t\t\t\t\t\t\t\t\theight=\"20\"\r\n\t\t\t\t\t\t\t\t\tviewBox=\"0 0 24 24\"\r\n\t\t\t\t\t\t\t\t\tfill=\"none\"\r\n\t\t\t\t\t\t\t\t\tstroke=\"#666\"\r\n\t\t\t\t\t\t\t\t\tstroke-width=\"2\"\r\n\t\t\t\t\t\t\t\t\tstroke-linecap=\"round\"\r\n\t\t\t\t\t\t\t\t\tstroke-linejoin=\"round\"\r\n\t\t\t\t\t\t\t\t\t><circle cx=\"12\" cy=\"12\" r=\"3\" /><path\r\n\t\t\t\t\t\t\t\t\t\td=\"M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z\"\r\n\t\t\t\t\t\t\t\t\t/></svg\r\n\t\t\t\t\t\t\t\t></span\r\n\t\t\t\t\t\t\t></span\r\n\t\t\t\t\t\t>{/if}\r\n\t\t\t\t</h2>\r\n\t\t\t{:else}\r\n\t\t\t\t<input class=\"setEditMode\" bind:value={newTitle} />\r\n\t\t\t\t<button on:click={updateTitle}>Update</button>\r\n\t\t\t\t<button on:click={del}>delete</button><br />\r\n\t\t\t\t<span class=\"arrowIcon\"\r\n\t\t\t\t\t><svg\r\n\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\r\n\t\t\t\t\t\twidth=\"20\"\r\n\t\t\t\t\t\theight=\"20\"\r\n\t\t\t\t\t\tviewBox=\"0 0 24 24\"\r\n\t\t\t\t\t\tfill=\"none\"\r\n\t\t\t\t\t\tstroke=\"#ccc\"\r\n\t\t\t\t\t\tstroke-width=\"2\"\r\n\t\t\t\t\t\tstroke-linecap=\"round\"\r\n\t\t\t\t\t\tstroke-linejoin=\"round\"\r\n\t\t\t\t\t\t><circle cx=\"12\" cy=\"12\" r=\"10\" /><path\r\n\t\t\t\t\t\t\td=\"M12 8l4 4-4 4M8 12h7\"\r\n\t\t\t\t\t\t/></svg\r\n\t\t\t\t\t></span\r\n\t\t\t\t>\r\n\t\t\t\t{#each $bookmarks as group, index}\r\n\t\t\t\t\t{#if index !== $appState.currentTabIndex}\r\n\t\t\t\t\t\t<span\r\n\t\t\t\t\t\t\tclass=\"availableTab\"\r\n\t\t\t\t\t\t\ton:click={() => moveSet(index)}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t{$bookmarks[index].title}\r\n\t\t\t\t\t\t</span>\r\n\t\t\t\t\t{/if}\r\n\t\t\t\t{/each}\r\n\t\t\t{/if}\r\n\t\t</section>\r\n\t\t<section\r\n\t\t\tclass=\"setContents\"\r\n\t\t\tuse:dndzone={{\r\n\t\t\t\titems,\r\n\t\t\t\ttype: \"link\",\r\n\t\t\t\tdropTargetStyle: { \"min-height\": \"40px\" },\r\n\t\t\t}}\r\n\t\t\ton:consider={handleDndConsider}\r\n\t\t\ton:finalize={handleDndFinalize}\r\n\t\t>\r\n\t\t\t{#each items as link, index (link.id)}\r\n\t\t\t\t<Link {link} {groupIndex} {setIndex} linkIndex={index} />\r\n\t\t\t{/each}\r\n\t\t</section>\r\n\t</section>\r\n</slot>\r\n\r\n<style>\r\n\th2 {\r\n\t\tmargin-top: 0;\r\n\t\tpadding-top: 0px;\r\n\t\tcolor: #eee;\r\n\t}\r\n\r\n\th2 span.setControls {\r\n\t\tcolor: #ccc;\r\n\t\tfont-size: 0.8em;\r\n\t\tfont-weight: normal;\r\n\t}\r\n\r\n\t.availableTab {\r\n\t\tfont-size: larger;\r\n\t\tdisplay: inline-block;\r\n\t\tpadding-left: 10px;\r\n\t\tcolor: #fff;\r\n\t}\r\n\r\n\t.availableTab:hover {\r\n\t\tcursor: pointer;\r\n\t\ttext-decoration: underline;\r\n\t}\r\n\r\n\t.arrowIcon {\r\n\t\tdisplay: inline-block;\r\n\t\tmargin-bottom: 0px;\r\n\t}\r\n\r\n\tsection.setContainer {\r\n\t\tbackground-color: #222;\r\n\t\tborder-radius: 15px;\r\n\t\tmargin-bottom: 10px;\r\n\t\tpadding: 20px;\r\n\t\toverflow-x: hidden;\r\n\t\tdisplay: block;\r\n\t\t-webkit-column-break-inside: avoid;\r\n\t}\r\n\r\n\t.editLink {\r\n\t\tcursor: pointer;\r\n\t\tdisplay: inline-block;\r\n\t\tmargin-left: 10px;\r\n\t}\r\n</style>\r\n","<script>\r\n\timport { dndzone } from \"svelte-dnd-action\";\r\n\timport { bookmarks } from \"./stores\";\r\n\texport let group, groupIndex;\r\n\timport Set from \"./Set.svelte\";\r\n\r\n\tlet items;\r\n\r\n\t$: items = group.sets;\r\n\r\n\tfunction handleDndConsider(e) {\r\n\t\titems = e.detail.items;\r\n\t\tconsole.log(e.detail);\r\n\t\t$bookmarks[groupIndex].sets = e.detail.items;\r\n\t}\r\n\r\n\tfunction handleDndFinalize(e) {\r\n\t\titems = e.detail.items;\r\n\t\t$bookmarks[groupIndex].sets = e.detail.items;\r\n\t}\r\n</script>\r\n\r\n<section class=\"sets-container\">\r\n\t<section>\r\n\t\t{#if groupIndex !== 0}\r\n\t\t\t<!--display the inbox in all groups-->\r\n\t\t\t<Set set={$bookmarks[0].sets[0]} setIndex=\"0\" groupIndex=\"0\" />\r\n\t\t{/if}\r\n\t</section>\r\n\t<section\r\n\t\tuse:dndzone={{\r\n\t\t\titems,\r\n\t\t\ttype: \"set\",\r\n\t\t\tdropTargetStyle: { \"min-height\": \"40px\" },\r\n\t\t}}\r\n\t\ton:consider={handleDndConsider}\r\n\t\ton:finalize={handleDndFinalize}\r\n\t>\r\n\t\t{#each items as set, index (set.id)}\r\n\t\t\t<Set {set} setIndex={index} {groupIndex} />\r\n\t\t{/each}\r\n\t</section>\r\n</section>\r\n\r\n<style>\r\n\tsection.sets-container {\r\n\t\tfont-size: 1em;\r\n\t\tcolumn-count: auto;\r\n\t\tcolumn-width: 320px;\r\n\t\tcolumn-gap: 20px;\r\n\t}\r\n</style>\r\n","<script>\r\n\timport { config, appState, bookmarks } from \"./stores\";\r\n\timport Group from \"./Group.svelte\";\r\n\tlet filter, newUrl;\r\n\r\n\tasync function getBookmarksFromFilesystem() {\r\n\t\tconst response = await fetch($config.ajaxURL, {\r\n\t\t\tmethod: \"post\",\r\n\t\t\theaders: {\r\n\t\t\t\tAccept: \"application/json, text/plain, /\",\r\n\t\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\t},\r\n\t\t\tbody: JSON.stringify({ action: \"load\" }),\r\n\t\t})\r\n\t\t\t.then((response) => response.json())\r\n\t\t\t.then((data) => {\r\n\t\t\t\tbookmarks.set(data);\r\n\t\t\t});\r\n\t}\r\n\tgetBookmarksFromFilesystem();\r\n\r\n\tfunction getNextLinkId() {\r\n\t\tlet number = 0;\r\n\t\tlet highestNumber = 0;\r\n\t\t$bookmarks.forEach((group) => {\r\n\t\t\tgroup.sets.forEach((set) => {\r\n\t\t\t\tset.contents.forEach((link) => {\r\n\t\t\t\t\tnumber = parseInt(\r\n\t\t\t\t\t\tlink.id.slice(link.id.lastIndexOf(\"-\") + 1)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (number > highestNumber) highestNumber = number;\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn highestNumber + 1;\r\n\t}\r\n\r\n\tfunction getNextSetId() {\r\n\t\tlet number = 0;\r\n\t\tlet highestNumber = 0;\r\n\t\t$bookmarks.forEach((group) => {\r\n\t\t\tgroup.sets.forEach((set) => {\r\n\t\t\t\tnumber = parseInt(set.id.slice(set.id.lastIndexOf(\"-\") + 1));\r\n\t\t\t\tif (number > highestNumber) highestNumber = number;\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn highestNumber + 1;\r\n\t}\r\n\r\n\tfunction addLink() {\r\n\t\tif (/^http(s)?:\\/\\//.test(newUrl) === true) {\r\n\t\t\tconst nextId = getNextLinkId();\r\n\t\t\tconsole.log(nextId);\r\n\r\n\t\t\tconst newLink = {\r\n\t\t\t\tid: \"link-\" + nextId,\r\n\t\t\t\ttitle: newUrl,\r\n\t\t\t\turl: newUrl,\r\n\t\t\t\tdisplay: true,\r\n\t\t\t\tdataType: \"link\",\r\n\t\t\t};\r\n\r\n\t\t\tfetch($config.ajaxURL, {\r\n\t\t\t\tmethod: \"post\",\r\n\t\t\t\theaders: {\r\n\t\t\t\t\tAccept: \"application/json, text/plain, /\",\r\n\t\t\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\t\t},\r\n\t\t\t\tbody: JSON.stringify({ action: \"lookup\", url: newUrl }),\r\n\t\t\t}).then(function (response) {\r\n\t\t\t\tresponse.text().then(function (data) {\r\n\t\t\t\t\tconsole.log(data);\r\n\t\t\t\t\t$bookmarks[0].sets[0].contents[0].title = data;\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\t$bookmarks[0].sets[0].contents.unshift(newLink);\r\n\t\t\t$bookmarks = $bookmarks;\r\n\t\t\tnewUrl = \"\";\r\n\t\t} else {\r\n\t\t\tconst nextId = getNextSetId();\r\n\r\n\t\t\tconst newSet = {\r\n\t\t\t\tid: \"set-\" + nextId,\r\n\t\t\t\ttitle: newUrl,\r\n\t\t\t\tcontents: [],\r\n\t\t\t\tdisplay: true,\r\n\t\t\t\tdataType: \"set\",\r\n\t\t\t};\r\n\r\n\t\t\tconsole.log(newSet);\r\n\r\n\t\t\tlet positionInNewGroup = $appState.currentTabIndex == 0 ? 1 : 0;\r\n\t\t\t$bookmarks[$appState.currentTabIndex].sets.splice(\r\n\t\t\t\tpositionInNewGroup,\r\n\t\t\t\t0,\r\n\t\t\t\tnewSet\r\n\t\t\t);\r\n\r\n\t\t\t$bookmarks = $bookmarks;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reFilter(event) {\r\n\t\tconsole.log(filter);\r\n\t\t/* Step 1 - Find text links that match */\r\n\t\tlet activeLinks = 0;\r\n\t\tlet filteredBookmarks = $bookmarks;\r\n\r\n\t\tfilteredBookmarks.forEach((group, groupIndex) => {\r\n\t\t\tfilteredBookmarks[groupIndex].sets.forEach((set, setIndex) => {\r\n\t\t\t\tset.contents.forEach((link, linkIndex) => {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tlink.title.toLowerCase().indexOf(filter) > -1 ||\r\n\t\t\t\t\t\tfilter == \"\"\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tfilteredBookmarks[groupIndex].sets[setIndex].contents[\r\n\t\t\t\t\t\t\tlinkIndex\r\n\t\t\t\t\t\t].display = true;\r\n\t\t\t\t\t\tactiveLinks++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfilteredBookmarks[groupIndex].sets[setIndex].contents[\r\n\t\t\t\t\t\t\tlinkIndex\r\n\t\t\t\t\t\t].display = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tconsole.log(activeLinks);\r\n\t\t$bookmarks = filteredBookmarks;\r\n\t}\r\n\r\n\tfunction saveBookmarks() {\r\n\t\tconsole.log(\"saving...\");\r\n\r\n\t\tfetch($config.ajaxURL, {\r\n\t\t\tmethod: \"post\",\r\n\t\t\theaders: {\r\n\t\t\t\tAccept: \"application/json, text/plain, /\",\r\n\t\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\t},\r\n\t\t\tbody: JSON.stringify({ action: \"save\", json: $bookmarks }),\r\n\t\t}).then((res) => console.log(res));\r\n\t}\r\n\r\n\tfunction switchTab() {\r\n\t\tconsole.log(\"switch\");\r\n\t}\r\n</script>\r\n\r\n<main>\r\n\t<section id=\"controls\">\r\n\t\t<div id=\"addBox\">\r\n\t\t\t<input bind:value={newUrl} />\r\n\t\t\t<button on:click={addLink}>Add</button>\r\n\t\t</div>\r\n\t\t<div>Filter: <input bind:value={filter} on:input={reFilter} /></div>\r\n\t</section>\r\n\r\n\t<ul id=\"tabMenu\">\r\n\t\t{#each $bookmarks as group, index}\r\n\t\t\t{#if index == $appState.currentTabIndex}\r\n\t\t\t\t<li class=\"selectedTab\">{$bookmarks[index].title}</li>\r\n\t\t\t{:else}\r\n\t\t\t\t<li\r\n\t\t\t\t\tclass=\"availableTab\"\r\n\t\t\t\t\ton:click={() => ($appState.currentTabIndex = index)}\r\n\t\t\t\t>\r\n\t\t\t\t\t{$bookmarks[index].title}\r\n\t\t\t\t</li>\r\n\t\t\t{/if}\r\n\t\t\t<span class=\"separator\">/</span>\r\n\t\t{/each}\r\n\t\t<button on:click={saveBookmarks}>Save data</button>\r\n\t\t<span class=\"separator\">/</span>\r\n\t</ul>\r\n\r\n\t<section class=\"groups-container\">\r\n\t\t{#each $bookmarks as group, index}\r\n\t\t\t{#if index == $appState.currentTabIndex}\r\n\t\t\t\t<Group {group} groupIndex={index} />\r\n\t\t\t{/if}\r\n\t\t{/each}\r\n\t</section>\r\n</main>\r\n\r\n<style>\r\n\t#controls {\r\n\t\tdisplay: flex;\r\n\t\tflex-wrap: wrap;\r\n\t\tjustify-content: space-between;\r\n\t}\r\n\r\n\t#addBox {\r\n\t\tflex-basis: 70%;\r\n\t}\r\n\r\n\t#addBox input {\r\n\t\twidth: 80%;\r\n\t}\r\n\r\n\t#tabMenu {\r\n\t\tmargin: 0;\r\n\t\tpadding: 20px 0;\r\n\t}\r\n\r\n\t#tabMenu li {\r\n\t\tdisplay: inline-block;\r\n\t\tpadding: 0;\r\n\t\tfont-size: 1.5em;\r\n\t}\r\n\r\n\t#tabMenu span.separator {\r\n\t\tdisplay: inline-block;\r\n\t\tpadding: 0 10px;\r\n\t}\r\n\r\n\tli.selectedTab {\r\n\t\tcolor: #fff;\r\n\t}\r\n\t/*\r\n\tmain {\r\n\t\ttext-align: center;\r\n\t\tpadding: 1em;\r\n\t\tmax-width: 240px;\r\n\t\tmargin: 0 auto;\r\n\t}\r\n\r\n\th1 {\r\n\t\tcolor: #ff3e00;\r\n\t\ttext-transform: uppercase;\r\n\t\tfont-size: 4em;\r\n\t\tfont-weight: 100;\r\n\t}*/\r\n\r\n\t@media (max-width: 640px) {\r\n\t\t#addBox {\r\n\t\t\tflex-basis: auto;\r\n\t\t}\r\n\r\n\t\t#addBox input {\r\n\t\t\twidth: 300px;\r\n\t\t}\r\n\t}\r\n</style>\r\n","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {\n\t\t/*name: 'Richard'*/\n\t}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","component_subscribe","component","store","callback","$$","on_destroy","push","callbacks","unsub","subscribe","unsubscribe","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","tar","src","k","assign","slice","get_slot_changes","dirty","lets","undefined","merged","len","Math","max","length","i","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","p","get_all_dirty_from_scope","set_store_value","ret","value","set","action_destroyer","action_result","destroy","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","set_data","wholeText","set_input_value","input","current_component","set_current_component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","update","pop","has","add","clear","fragment","before_update","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","outro_and_destroy_block","lookup","key","update_keyed_each","old_blocks","get_key","dynamic","list","create_each_block","next","get_context","n","old_indexes","new_blocks","new_lookup","Map","deltas","child_ctx","get","abs","will_move","did_move","m","first","new_block","old_block","new_key","old_key","create_component","mount_component","customElement","on_mount","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","skip_bound","root","ready","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","$destroy","this","$on","type","index","indexOf","splice","$set","$$props","obj","$$set","keys","subscriber_queue","writable","start","stop","subscribers","new_value","run_queue","subscriber","invalidate","size","bookmarks","id","title","sets","appState","currentTabIndex","ajaxURL","window","location","hostname","config","dispatchFinalizeEvent","el","items","info","dispatchEvent","CustomEvent","detail","dispatchConsiderEvent","DRAGGED_ENTERED_EVENT_NAME","DRAGGED_LEFT_EVENT_NAME","DRAGGED_OVER_INDEX_EVENT_NAME","DRAGGED_LEFT_DOCUMENT_EVENT_NAME","DRAGGED_LEFT_TYPES","dispatchDraggedElementEnteredContainer","containerEl","indexObj","draggedEl","dispatchDraggedElementLeftContainerForAnother","theOtherDz","dispatchDraggedElementIsOverIndex","TRIGGERS","SOURCES","SHADOW_ITEM_MARKER_PROPERTY_NAME","SHADOW_ELEMENT_ATTRIBUTE_NAME","SHADOW_PLACEHOLDER_ITEM_ID","ITEM_ID_KEY","activeDndZoneCount","incrementActiveDropZoneCount","decrementActiveDropZoneCount","Error","isOnServer","getBoundingRectNoTransforms","ta","rect","getBoundingClientRect","style","getComputedStyle","tx","transform","sx","sy","dx","dy","startsWith","split","to","transformOrigin","x","parseFloat","y","w","width","offsetWidth","h","height","offsetHeight","top","right","bottom","left","getAbsoluteRectNoTransforms","scrollY","scrollX","getAbsoluteRect","findCenter","isPointInsideRect","point","findCenterOfElement","isCenterOfAInsideB","elA","elB","calcDistanceBetweenCenters","centerOfA","centerOfB","pointA","pointB","sqrt","pow","dzToShadowIndexToRect","resetIndexesCache","findWouldBeIndex","floatingAboveEl","collectionBelowEl","isProximityBased","shadowElIndex","dz","findIndex","child","cacheShadowRect","cachedShadowRect","indexOfMin","minDistanceSoFar","Number","MAX_VALUE","distance","makeScroller","scrollingInfo","resetScrolling","directionObj","stepPx","scrollContainer","scrollBy","requestAnimationFrame","calcScrollStepPx","distancePx","scrollIfNeeded","pointer","elementToScroll","distances","min","documentElement","clientWidth","calcInnerDistancesBetweenPointAndSidesOfElement","isAlreadyScrolling","scrollingVertically","scrollingHorizontally","scrollHeight","clientHeight","scrollWidth","toString","object","JSON","stringify","getDepth","_getDepth","countSoFar","parentElement","observe","dropZones","intervalMs","lastDropZoneFound","lastIndexFound","lastCentrePositionOfDragged","lastIsDraggedInADropZone","dropZonesFromDeepToShallow","sort","dz1","dz2","andNow","currentCenterOfDragged","setTimeout","isElementOffDocument","dispatchDraggedLeftDocument","isDraggedInADropZone","dispatchDraggedElementLeftContainerForNone","mousePosition","updateMousePosition","e","touches","clientX","clientY","loop","trs","property","morphDraggedElementToBeLike","copyFromEl","currentMouseX","currentMouseY","transformDraggedElement","newRect","draggedElRect","widthChange","heightChange","relativeDistanceOfMousePointerFromDraggedSides","copyStylesFromTo","copyToEl","computedStyle","s","setProperty","getPropertyValue","getPropertyPriority","styleDraggable","draggableEl","dragDisabled","draggable","ondragstart","userSelect","WebkitUserSelect","cursor","styleActiveDropZones","getStyles","getClasses","styles","classList","styleInactiveDropZones","contains","remove","DEFAULT_DROP_TARGET_STYLE","outline","originalDragTarget","draggedElData","draggedElType","originDropZone","originIndex","shadowElData","shadowElDropZone","dragStartMousePosition","currentMousePosition","unlockOriginDzMinDimensions","isWorkingOnPreviousDrag","finalizingPreviousDrag","isDraggedOutsideOfAnyDz","typeToDropZones","dzToConfig","elToMouseDownListener","WeakMap","unregisterDropZone","dropZoneEl","watchDraggedElement","handleDraggedEntered","handleDraggedLeft","handleDraggedIsOverIndex","handleDrop","observationIntervalMs","dropAnimationDurationMs","unWatchDraggedElement","clearTimeout","findShadowElementIdx","item","dropFromOthersDisabled","currentTarget","newOriginZoneItems","trigger","source","shadowPlaceHolderIdx","findShadowPlaceHolderIdx","shadowElIdx","shadowItem","originZoneItems","handleMouseMove","preventDefault","moveDraggedElementToWasDroppedState","dropTargetStyle","dropTargetClasses","shadowElRect","newTransform","transition","animateDraggedToFinalPosition","shadowEl","visibility","dndzone","flipDurationMs","morphDisabled","centreDraggedOnCursor","elToIdx","removeMaybeListeners","handleMouseMoveMaybeDragStart","handleFalseAlarm","currentIdx","rootNode","getRootNode","originDropZoneRoot","body","placeHolderElData","keepOriginalElementInDom","dragTarget","focus","display","position","zIndex","originalElement","positionCenterOnXY","cloneNode","elTopPx","elLeftPx","center","margin","boxSizing","createDraggedElementFrom","originalMinHeight","minHeight","originalMinWidth","minWidth","preventShrinking","passive","capture","handleDragStart","handleMouseDown","isContentEditable","button","stopPropagation","configure","newType","getConfigProp","propName","objA","objB","keyA","hasOwnProperty","call","areObjectsShallowEqual","arrA","arrB","areArraysShallowEqualSameOrder","idx","newOptions","INSTRUCTION_IDs","DND_ZONE_ACTIVE","DND_ZONE_DRAG_DISABLED","ID_TO_INSTRUCTION","alertsDiv","initAriaOnBrowser","opacity","prepend","entries","txt","div","innerHTML","instructionToHiddenDiv","alertToScreenReader","alertText","draggedItemType","focusedDz","focusedItem","focusedItemId","isDragging","focusedDzLabel","focusedItemLabel","allDragTargets","WeakSet","elToKeyDownListeners","elToFocusListeners","dzToHandles","readyState","globalKeyDownHandler","globalClickHandler","activeElement","handleZoneFocus","newlyFocusedDz","originItems","originItem","find","originIdx","itemToMove","targetItems","autoAriaDisabled","unshift","triggerAllDzsUpdate","dispatchConsider","blur","zoneTabIndex","swap","arr","j","handleKeyDown","disabled","href","focusedItemIdx","tabIndex","setCurrentFocusedItem","dropTargets","msg","handleClick","handles","validateOptions","pointerZone","pointerDndZone","keyboardZone","keyboardDndZone","console","warn","itemWithMissingId","isArray","isNaN","isInt","url","newTitle","link","groupIndex","setIndex","linkIndex","titleEditable","$bookmarks","contents","editMode","moveSet","newGroupIndex","log","movedSet","group","newUrl","fetch","$config","method","headers","Accept","action","response","json","getBookmarksFromFilesystem","test","nextId","number","highestNumber","parseInt","lastIndexOf","getNextLinkId","newLink","dataType","newSet","getNextSetId","positionInNewGroup","$appState","activeLinks","filteredBookmarks","toLowerCase","res"],"mappings":"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"}